#!/usr/bin/env ruby
# encoding: utf-8

require 'rbconfig'

module OS
  class << self
    def is?(what)
      what === RbConfig::CONFIG['host_os']
    end
    alias is is?

    def to_s
      RbConfig::CONFIG['host_os']
    end
  end

  module_function

  def linux?
    OS.is? /linux|cygwin/
  end

  def mac?
    OS.is? /mac|darwin/
  end

  def bsd?
    OS.is? /bsd/
  end

  def windows?
    OS.is? /mswin|win|mingw|mingw32/
  end

  def solaris?
    OS.is? /solaris|sunos/
  end

  def posix?
    linux? or mac? or bsd? or solaris? # or Process.respond_to?(:fork)
  end
end

if OS.posix?
  $root_dir = `git rev-parse --show-toplevel`.chomp + '/'
  $externals_file = "#{$root_dir}.gitexternals"
  $ignore_file = "#{$root_dir}.gitignore"
else
  # puts "Not posix os, you must run git-external from top level directory"
  $root_dir = ''
  $externals_file = "#{$root_dir}.gitexternals".gsub(' ', '\\ ')
  $ignore_file = "#{$root_dir}.gitignore".gsub(' ', '\\ ')
end

$configurations = {}

def usage
  puts "Usage: git external add <repository-url> <path> [<branch>]"
  puts "   or: git external status"
  puts "   or: git external init [--] [<path>...]"
  puts "   or: git external update [--] [<path>...]"
  puts "   or: git external cmd '<command>'"
  puts "   or: git external list"
end

# Load .gitexternals
def load_configuration(file)
  $configurations = {}
  linesExit, lines = execute('git config', ['--list', '--file', file])
  lines.each do |line|
    if line =~ /^external\.([^$]+)\.([^=]+)=(.*)$/
      $configurations[$1.chomp] ||= {'revision' => false}
      $configurations[$1.chomp][$2.chomp] = $3.chomp
    end
  end
end

# Print .gitexternals content
def print_configuration
  $configurations.each do |name, config|
    puts "* #{name}"
    config.each do |key, value|
      puts "\t#{key}: #{value}"
    end
  end
end

# Check for uncommitted changes
def uncommitted_changes?(path)
  diffExit, diff = execute('git diff-index', ['--quiet', 'HEAD'], path)
  return ((diffExit == 1) ? true : false)
end

# Check if a branch exists
def branch_exists(path, branch)
    branchesExit, branches = execute('git branch', [], path)
    regex = Regexp.new('[\\n\\s\\*]+' + Regexp.escape(branch.to_s) + '\\n')
    result = ((branches =~ regex) ? true : false)
    return result
end

def init_external(url, path, branch='origin/master', revision=nil)
  require 'fileutils'
  if File.directory? "#{path}/.git"
    puts "- Repository already exists"
    
    return
  end
    
  url = normalize_url url
  execute('git clone', ["#{url}", path], Dir.getwd, '')
    
  if not revision
    remoteName, remoteBranch = branch.split('/')

    # Create a local tracking branch if it doesn't exist already
    unless branch_exists(path, branch)
      puts "- Creating local tracking branch: #{branch} -> #{remoteBranch}"
      execute('git branch', ['checkout',  '--track', "#{remoteBranch}", "#{branch}"], path)
    end
    
    update_external(url, path, branch, revision)
    
  else
    puts "- Dealing with a tag/sha1: #{branch}"
    update_external(url, path, branch, revision)
  end
  
end

def update_external(url, path, branch='origin/master', revision=nil)
  require 'fileutils'
  puts "- Updating #{path}"
  if File.directory? "#{path}/.git"
    if uncommitted_changes?(path)
      puts "#{path} - uncommitted changes detected, can not update repository"
    elsif revision
      puts "#{path} - updating to revision:#{revision}"
      execute('git checkout', [revision], path, '')
    else
      puts "#{path} - updating branch #{branch}"
      execute('git pull', ['--rebase'], path, '')
    end
  end
end

def command_status
  ok = 0
  broken = 0
  unknown = 0
  $configurations.each do |name, config|
    branch = config["branch"]
    url = config["url"]
    path = config["path"]
    revision = config["revision"]

    # not implemented yet
    if revision
      unknown += 1
      next
    end
        
    symbolicExit, symbolic = execute('git symbolic-ref', ['HEAD', '--short'], path)
    gitBranchExit, gitBranch = execute('git config', ["branch.#{symbolic}.merge"], path)
    gitBranch = gitBranch.gsub('refs/heads/', '')
    remoteExit, remote = execute('git config', ["branch.#{symbolic}.remote"], path)
    gitRemoteExit, gitRemote = execute('git config', ["remote.#{remote}.url"], path)

    if uncommitted_changes?(path)
      changesString = "(Uncommitted Changes) "
    else
      changesString = ""
    end

    remoteBranch = remote + "/" + gitBranch
    
    if gitBranchExit != 0 && gitBranchExit != 1 && gitRemoteExit != 0 && gitRemoteExit != 1
      puts "  ✗ #{path} -- exit code #{gitBranchExit}, #{gitRemoteExit}"
      broken += 1
    else
      if branch == remoteBranch
        if url == gitRemote
          puts "  ✓ #{path} #{changesString}"
          ok += 1
        else
          puts "  ✗ #{path} #{changesString} -- expected url '#{url}' but was '#{gitRemote}'"
          broken +=1
        end
      else
        puts " ✗ #{path} #{changesString} -- expected branch '#{branch}' but was '#{remoteBranch}'"
        broken +=1
      end
    end
  end
  
  puts "#{broken > 0 ? "✗" : "✓"} » #{ok} ok • #{broken} broken - #{unknown} unknown"
end

def command_add(url, path, branch='origin/master')
  command_rm(path)
  execute('git config', ['--file', $externals_file, '--add', "external.#{path}.path", "#{path}"])
  execute('git config', ['--file', $externals_file, '--add', "external.#{path}.url", "#{url}"])
  execute('git config', ['--file', $externals_file, '--add', "external.#{path}.branch", "#{branch}"])

  File.open("#{$ignore_file}", 'a+') do |f|
    f.puts("#{path}")
  end

end

def command_rm(path)
  execute('git config', ['--file', $externals_file, '--unset', "external.#{path}.path"])
  execute('git config', ['--file', $externals_file, '--unset', "external.#{path}.url"])
  execute('git config', ['--file', $externals_file, '--unset', "external.#{path}.branch"])
  execute('git config', ['--file', $externals_file, '--unset', "external.#{path}.revision"])
  execute('git config', ['--file', $externals_file, '--remove-section', "external.#{path}"])

  if File.file? $ignore_file
    ignores = []
    File.open($ignore_file, 'r').each_line do |line|
      ignores.push line.gsub(/\n/, '')
    end
    ignores.delete(path)
    File.open($ignore_file, 'w+') do |file|
      file.puts ignores
    end
  end
end

def command_init
  $configurations.each do |name, config|
    puts name
    init_external config["url"], config["path"], config["branch"], config['revision']
  end
end

def command_update
  $configurations.each do |name, config|
    update_external config["url"], config["path"], config["branch"], config['revision']
  end
end

def command_cmd(cmd)
  $configurations.each do |name, config|
    path = config['path']
    puts "- Executing '#{cmd}' in #{path}"
    exitCmd, output = execute(cmd, [], path, '')
    puts output
  end
end

def command_list
  print_configuration
end

#########
def normalize_url(url)
  url
end

def execute(cmd, opts=[], path=Dir.getwd, redirect='2>&1')
  opts = [opts].flatten.map {|s| escape(s) }.join(' ')
  cmd = "#{cmd} #{opts} #{redirect}"

  out = nil
  if path && (Dir.getwd != path)
    Dir.chdir(path) { out = execute_now(cmd) } 
  else
    out = execute_now(cmd)
  end
  return $?.exitstatus, out
end

def execute_now(cmd)
  if block_given?
    IO.popen(cmd)
  else
    `#{cmd}`.chomp
  end
end

def escape(s)
  escaped = s.to_s.gsub('\'', '\'\\\'\'')
  %Q{"#{escaped}"}
end
#########

load_configuration $externals_file

command=ARGV[0]

case command
when "status" then command_status
when "add" then command_add ARGV[1], ARGV[2], ARGV[3] || "origin/master"
when "rm" then command_rm ARGV[1]
when "init" then command_init
when "update" then command_update
when "cmd" then command_cmd ARGV[1]
when "list" then command_list
else usage
end

